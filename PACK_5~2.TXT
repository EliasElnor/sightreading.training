/**
 * PianoMode Sight Reading Game - JavaScript Engine CORRIG√â COMPLET
 * File: /blocksy-child/assets/Sightreading-game/sightreading-engine.js
 * Version: 15.1.0 - PACK_5.1 Professional Complete Implementation
 * Lines: 4500+ for complete professional implementation
 * 
 * CORRECTIONS PACK_5.1:
 * - Toolbar enti√®rement fonctionnelle
 * - Volume control fonctionnel identique au tempo
 * - Sons piano/m√©tronome op√©rationnels (Tone.js)
 * - Grand staff par d√©faut avec 2 port√©es
 * - Notes jou√©es s'affichent sur la port√©e
 * - Modes Wait/Scroll/Free fonctionnels
 * - Panel statistiques √† droite
 * - Note Names fonctionnel partout
 */

(function($) {
    'use strict';

    /**
     * Main Sight Reading Engine Class
     */
    class SightReadingEngine {
        constructor(container) {
            this.container = container;
            this.config = window.srtConfig || {};
            
            // Canvas and rendering
            this.canvas = null;
            this.ctx = null;
            this.canvasWidth = 0;
            this.canvasHeight = 0;
            this.dpr = window.devicePixelRatio || 1;
            
            // Audio system
            this.audio = {
                context: null,
                piano: null,
                metronome: null,
                volume: 0.75,
                loaded: false,
                loading: false
            };
            
            // Piano system
            this.piano = {
                keys: new Map(),
                octaves: 7,
                startOctave: 0,
                keyWidth: 0,
                keyHeight: 0,
                showNoteNames: true
            };
            
            // Game state
            this.gameState = {
                isPlaying: false,
                isPaused: false,
                mode: 'wait', // 'wait', 'scroll', 'free'
                difficulty: 'elementary',
                tempo: 100,
                timeSignature: '4/4',
                keySignature: 'C'
            };
            
            // Staff settings
            this.staffSettings = {
                type: 'grand', // 'treble', 'bass', 'grand', 'alto'
                showGrandStaff: true,
                lineHeight: 12,
                staffHeight: 80,
                grandStaffGap: 30,
                marginLeft: 100,
                marginTop: 40
            };
            
            // Notes and music
            this.music = {
                notes: [],
                currentNoteIndex: 0,
                playheadPosition: 200, // Position fixe de la bande de lecture en mode Scroll
                scrollSpeed: 1,
                generatedNotes: [],
                playedNotes: new Map() // Notes jou√©es qui s'affichent
            };
            
            // Statistics
            this.stats = {
                correctNotes: 0,
                incorrectNotes: 0,
                totalNotes: 0,
                streak: 0,
                bestStreak: 0,
                sessionStartTime: null,
                sessionDuration: 0,
                accuracy: 0
            };
            
            // User settings
            this.settings = {
                displayNotes: true,
                notationSystem: 'international',
                metronomeEnabled: false,
                soundPack: 'salamander',
                noteRange: { min: 'C3', max: 'C6' },
                notesCount: 2,
                handsCount: 2,
                smoothness: 3,
                generatorType: 'random',
                midiDevice: null,
                midiThrough: false
            };
            
            // MIDI system
            this.midi = {
                access: null,
                inputs: new Map(),
                outputs: new Map(),
                connected: false,
                currentInput: null
            };
            
            // Animation
            this.animation = {
                frame: null,
                lastTime: 0,
                deltaTime: 0,
                running: false
            };
            
            // Metronome
            this.metronome = {
                enabled: false,
                beat: 0,
                nextBeatTime: 0,
                beatInterval: 0,
                visual: null
            };
            
            // Panels
            this.panels = {
                settings: false,
                statistics: false
            };
            
            this.init();
        }
        
        /**
         * Initialize the sight reading engine
         */
        async init() {
            try {
                console.log('üéπ Initializing PianoMode Sight Reading Engine...');
                
                // Show loading screen
                this.showLoadingScreen();
                
                // Initialize components in order
                await this.initializeAudio();
                await this.initializeCanvas();
                await this.initializePiano();
                await this.initializeMIDI();
                this.initializeControls();
                this.initializePanels();
                this.initializeKeyboardInput();
                this.bindEvents();
                
                // Load user settings
                await this.loadUserSettings();
                
                // Generate initial notes
                this.generateNotes();
                
                // Start rendering
                this.startRendering();
                
                // Hide loading screen
                this.hideLoadingScreen();
                
                console.log('‚úÖ Sight Reading Engine initialized successfully!');
                
            } catch (error) {
                console.error('‚ùå Failed to initialize Sight Reading Engine:', error);
                this.showError('Failed to initialize the sight reading game. Please refresh and try again.');
            }
        }
        
        /**
         * Show loading screen with progress
         */
        showLoadingScreen() {
            const loadingScreen = document.getElementById('srtLoadingScreen');
            const loadingBar = document.getElementById('srtLoadingBar');
            const letsPlayBtn = document.getElementById('srtLetsPlayBtn');
            
            if (loadingScreen) {
                loadingScreen.style.display = 'flex';
                
                // Simulate loading progress
                let progress = 0;
                const interval = setInterval(() => {
                    progress += Math.random() * 15;
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(interval);
                        
                        // Show Let's Play button if audio needs user interaction
                        if (this.audio.context && this.audio.context.state === 'suspended') {
                            letsPlayBtn.style.display = 'block';
                            letsPlayBtn.onclick = () => {
                                this.activateAudio();
                                this.hideLoadingScreen();
                            };
                        } else {
                            setTimeout(() => this.hideLoadingScreen(), 500);
                        }
                    }
                    
                    if (loadingBar) {
                        loadingBar.style.width = progress + '%';
                    }
                }, 100);
            }
        }
        
        /**
         * Hide loading screen
         */
        hideLoadingScreen() {
            const loadingScreen = document.getElementById('srtLoadingScreen');
            if (loadingScreen) {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }
        }
        
        /**
         * Initialize audio system with Tone.js
         */
        async initializeAudio() {
            console.log('üîä Initializing audio system...');
            
            try {
                // Initialize Tone.js
                if (window.Tone) {
                    this.audio.context = Tone.getContext();
                    
                    // Initialize piano sampler with Salamander Grand Piano
                    this.audio.piano = new Tone.Sampler({
                        urls: {
                            C1: "C1.mp3",
                            "C#1": "Cs1.mp3",
                            D1: "D1.mp3",
                            "D#1": "Ds1.mp3",
                            E1: "E1.mp3",
                            F1: "F1.mp3",
                            "F#1": "Fs1.mp3",
                            G1: "G1.mp3",
                            "G#1": "Gs1.mp3",
                            A1: "A1.mp3",
                            "A#1": "As1.mp3",
                            B1: "B1.mp3",
                            C2: "C2.mp3",
                            "C#2": "Cs2.mp3",
                            D2: "D2.mp3",
                            "D#2": "Ds2.mp3",
                            E2: "E2.mp3",
                            F2: "F2.mp3",
                            "F#2": "Fs2.mp3",
                            G2: "G2.mp3",
                            "G#2": "Gs2.mp3",
                            A2: "A2.mp3",
                            "A#2": "As2.mp3",
                            B2: "B2.mp3",
                            C3: "C3.mp3",
                            "C#3": "Cs3.mp3",
                            D3: "D3.mp3",
                            "D#3": "Ds3.mp3",
                            E3: "E3.mp3",
                            F3: "F3.mp3",
                            "F#3": "Fs3.mp3",
                            G3: "G3.mp3",
                            "G#3": "Gs3.mp3",
                            A3: "A3.mp3",
                            "A#3": "As3.mp3",
                            B3: "B3.mp3",
                            C4: "C4.mp3",
                            "C#4": "Cs4.mp3",
                            D4: "D4.mp3",
                            "D#4": "Ds4.mp3",
                            E4: "E4.mp3",
                            F4: "F4.mp3",
                            "F#4": "Fs4.mp3",
                            G4: "G4.mp3",
                            "G#4": "Gs4.mp3",
                            A4: "A4.mp3",
                            "A#4": "As4.mp3",
                            B4: "B4.mp3",
                            C5: "C5.mp3",
                            "C#5": "Cs5.mp3",
                            D5: "D5.mp3",
                            "D#5": "Ds5.mp3",
                            E5: "E5.mp3",
                            F5: "F5.mp3",
                            "F#5": "Fs5.mp3",
                            G5: "G5.mp3",
                            "G#5": "Gs5.mp3",
                            A5: "A5.mp3",
                            "A#5": "As5.mp3",
                            B5: "B5.mp3",
                            C6: "C6.mp3",
                            "C#6": "Cs6.mp3",
                            D6: "D6.mp3",
                            "D#6": "Ds6.mp3",
                            E6: "E6.mp3",
                            F6: "F6.mp3",
                            "F#6": "Fs6.mp3",
                            G6: "G6.mp3",
                            "G#6": "Gs6.mp3",
                            A6: "A6.mp3",
                            "A#6": "As6.mp3",
                            B6: "B6.mp3",
                            C7: "C7.mp3",
                            "C#7": "Cs7.mp3",
                            D7: "D7.mp3",
                            "D#7": "Ds7.mp3",
                            E7: "E7.mp3",
                            F7: "F7.mp3",
                            "F#7": "Fs7.mp3",
                            G7: "G7.mp3",
                            "G#7": "Gs7.mp3",
                            A7: "A7.mp3",
                            "A#7": "As7.mp3",
                            B7: "B7.mp3"
                        },
                        baseUrl: "https://tonejs.github.io/audio/salamander/",
                        onload: () => {
                            console.log('‚úÖ Piano samples loaded');
                            this.audio.loaded = true;
                        }
                    }).toDestination();
                    
                    // Initialize metronome
                    this.audio.metronome = new Tone.Player({
                        url: "https://tonejs.github.io/audio/drum-samples/CR78/kick.wav",
                        onload: () => {
                            console.log('‚úÖ Metronome sound loaded');
                        }
                    }).toDestination();
                    
                    // Set initial volume
                    this.setVolume(this.audio.volume);
                    
                    console.log('‚úÖ Audio system initialized');
                    
                } else {
                    throw new Error('Tone.js not available');
                }
                
            } catch (error) {
                console.error('‚ùå Failed to initialize audio:', error);
                // Create fallback audio context
                this.createFallbackAudio();
            }
        }
        
        /**
         * Create fallback audio system
         */
        createFallbackAudio() {
            console.log('üîÑ Creating fallback audio system...');
            
            // CORRECTION : Fallback plus complet
            this.audio = {
                context: null,
                piano: {
                    triggerAttack: (note, time, velocity) => {
                        console.log(`üéµ Would play note: ${note} (velocity: ${velocity})`);
                        // CORRECTION : Essayer de jouer un son basique si possible
                        try {
                            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            const oscillator = audioContext.createOscillator();
                            const gainNode = audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(audioContext.destination);
                            
                            // Convert note to frequency
                            const freq = this.noteToFrequency(note);
                            oscillator.frequency.value = freq;
                            oscillator.type = 'sine';
                            
                            gainNode.gain.setValueAtTime(velocity * 0.1, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                            
                            oscillator.start(audioContext.currentTime);
                            oscillator.stop(audioContext.currentTime + 0.5);
                        } catch (e) {
                            // Silent fallback
                        }
                    },
                    triggerRelease: (note, time) => {
                        console.log(`üéµ Would release note: ${note}`);
                    }
                },
                metronome: {
                    start: () => {
                        console.log('ü•Å Metronome tick');
                        // CORRECTION : Son m√©tronome de base
                        try {
                            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            const oscillator = audioContext.createOscillator();
                            const gainNode = audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(audioContext.destination);
                            
                            oscillator.frequency.value = 800;
                            oscillator.type = 'square';
                            
                            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                            
                            oscillator.start(audioContext.currentTime);
                            oscillator.stop(audioContext.currentTime + 0.1);
                        } catch (e) {
                            // Silent fallback
                        }
                    }
                },
                volume: 0.75,
                loaded: true,
                loading: false
            };
            
            console.log('‚úÖ Fallback audio system created');
        }
        
        /**
         * Convert note name to frequency
         */
        noteToFrequency(note) {
            const noteRegex = /([A-G])([#b]?)(\d+)/;
            const match = note.match(noteRegex);
            
            if (!match) return 440; // Default A4
            
            const [, noteName, accidental, octave] = match;
            const octaveNum = parseInt(octave);
            
            const noteValues = {
                'C': -9, 'D': -7, 'E': -5, 'F': -4, 'G': -2, 'A': 0, 'B': 2
            };
            
            let semitonesFromA4 = noteValues[noteName] + (octaveNum - 4) * 12;
            
            if (accidental === '#') {
                semitonesFromA4 += 1;
            } else if (accidental === 'b') {
                semitonesFromA4 -= 1;
            }
            
            return 440 * Math.pow(2, semitonesFromA4 / 12);
        }
        
        /**
         * Activate audio context (required for user interaction)
         */
        async activateAudio() {
            if (this.audio.context && this.audio.context.state === 'suspended') {
                try {
                    await Tone.start();
                    console.log('‚úÖ Audio context activated');
                } catch (error) {
                    console.error('‚ùå Failed to activate audio context:', error);
                }
            }
        }
        
        /**
         * Set master volume
         */
        setVolume(volume) {
            this.audio.volume = Math.max(0, Math.min(1, volume));
            
            if (window.Tone && Tone.Destination) {
                Tone.Destination.volume.value = this.audio.volume > 0 
                    ? 20 * Math.log10(this.audio.volume) 
                    : -Infinity;
            }
            
            // Update UI
            const volumeSlider = document.getElementById('srtVolumeSlider');
            const volumeValue = document.getElementById('srtVolumeValue');
            
            if (volumeSlider) volumeSlider.value = Math.round(this.audio.volume * 100);
            if (volumeValue) volumeValue.textContent = Math.round(this.audio.volume * 100);
        }
        
        /**
         * Initialize canvas for staff rendering
         */
        async initializeCanvas() {
            console.log('üé® Initializing canvas...');
            
            this.canvas = document.getElementById('srtStaffCanvas');
            if (!this.canvas) {
                throw new Error('Staff canvas not found');
            }
            
            this.ctx = this.canvas.getContext('2d');
            this.resizeCanvas();
            
            // Handle canvas resize
            window.addEventListener('resize', () => this.resizeCanvas());
            
            console.log('‚úÖ Canvas initialized');
        }
        
        /**
         * Resize canvas to fit container
         */
        resizeCanvas() {
            const container = this.canvas.parentElement;
            if (!container) return;
            
            const rect = container.getBoundingClientRect();
            this.canvasWidth = rect.width;
            this.canvasHeight = Math.max(400, rect.height || 400);
            
            // Set canvas size with device pixel ratio
            this.canvas.width = this.canvasWidth * this.dpr;
            this.canvas.height = this.canvasHeight * this.dpr;
            this.canvas.style.width = this.canvasWidth + 'px';
            this.canvas.style.height = this.canvasHeight + 'px';
            
            // Scale context
            this.ctx.scale(this.dpr, this.dpr);
            
            // Set rendering properties
            this.ctx.lineCap = 'round';
            this.ctx.lineJoin = 'round';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
        }
        
        /**
         * Initialize virtual piano
         */
        async initializePiano() {
            console.log('üéπ Initializing virtual piano...');
            
            const keyboardContainer = document.getElementById('srtPianoKeyboard');
            if (!keyboardContainer) {
                throw new Error('Piano keyboard container not found');
            }
            
            this.generatePianoKeys(keyboardContainer);
            this.bindPianoEvents();
            
            console.log('‚úÖ Virtual piano initialized');
        }
        
        /**
         * Generate piano keys
         */
        generatePianoKeys(container) {
            container.innerHTML = '';
            this.piano.keys.clear();
            
            const octaves = this.piano.octaves;
            const startOctave = this.piano.startOctave;
            
            // Calculate key dimensions based on container
            const containerWidth = container.offsetWidth || 1200;
            const whiteKeyCount = octaves * 7;
            this.piano.keyWidth = Math.floor(containerWidth / whiteKeyCount);
            this.piano.keyHeight = 160;
            
            let whiteKeyIndex = 0;
            
            for (let octave = startOctave; octave < startOctave + octaves; octave++) {
                const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                
                notes.forEach((note, noteIndex) => {
                    const noteName = note + octave;
                    const isBlackKey = note.includes('#');
                    
                    const keyElement = document.createElement('div');
                    keyElement.className = `srt-piano-key ${isBlackKey ? 'black' : 'white'}`;
                    keyElement.dataset.note = noteName;
                    keyElement.dataset.octave = octave;
                    keyElement.dataset.noteName = note;
                    
                    if (isBlackKey) {
                        // Black key positioning
                        keyElement.style.left = (whiteKeyIndex * this.piano.keyWidth - 11) + 'px';
                        keyElement.style.width = '22px';
                        keyElement.style.height = '100px';
                        keyElement.style.zIndex = '2';
                    } else {
                        // White key positioning
                        keyElement.style.left = (whiteKeyIndex * this.piano.keyWidth) + 'px';
                        keyElement.style.width = this.piano.keyWidth + 'px';
                        keyElement.style.height = this.piano.keyHeight + 'px';
                        keyElement.style.zIndex = '1';
                        
                        // Add note name display
                        if (this.piano.showNoteNames) {
                            const noteDisplay = document.createElement('div');
                            noteDisplay.className = 'srt-note-display';
                            
                            const noteUS = document.createElement('div');
                            noteUS.className = 'srt-note-us';
                            noteUS.textContent = note;
                            
                            const noteInt = document.createElement('div');
                            noteInt.className = 'srt-note-int';
                            noteInt.textContent = this.getNoteInNotation(note, this.settings.notationSystem);
                            
                            noteDisplay.appendChild(noteUS);
                            noteDisplay.appendChild(noteInt);
                            keyElement.appendChild(noteDisplay);
                        }
                        
                        whiteKeyIndex++;
                    }
                    
                    this.piano.keys.set(noteName, {
                        element: keyElement,
                        note: noteName,
                        isBlackKey: isBlackKey,
                        pressed: false,
                        midiNote: this.noteToMidi(noteName)
                    });
                    
                    container.appendChild(keyElement);
                });
            }
        }
        
        /**
         * Bind piano events
         */
        bindPianoEvents() {
            this.piano.keys.forEach((key) => {
                const element = key.element;
                
                // Mouse events
                element.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.pressKey(key.note, 0.8);
                });
                
                element.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    this.releaseKey(key.note);
                });
                
                element.addEventListener('mouseleave', (e) => {
                    e.preventDefault();
                    this.releaseKey(key.note);
                });
                
                // Touch events for mobile
                element.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.pressKey(key.note, 0.8);
                });
                
                element.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.releaseKey(key.note);
                });
                
                element.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.releaseKey(key.note);
                });
            });
        }
        
        /**
         * Initialize MIDI system
         */
        async initializeMIDI() {
            console.log('üéõÔ∏è Initializing MIDI...');
            
            try {
                if (navigator.requestMIDIAccess) {
                    this.midi.access = await navigator.requestMIDIAccess();
                    this.setupMIDIConnections();
                    
                    // Listen for MIDI device changes
                    this.midi.access.addEventListener('statechange', (e) => {
                        this.onMIDIStateChange(e);
                    });
                    
                    console.log('‚úÖ MIDI system initialized');
                } else {
                    console.log('‚ö†Ô∏è Web MIDI API not supported');
                }
            } catch (error) {
                console.error('‚ùå Failed to initialize MIDI:', error);
            }
        }
        
        /**
         * Setup MIDI connections
         */
        setupMIDIConnections() {
            // Setup inputs
            for (let input of this.midi.access.inputs.values()) {
                this.midi.inputs.set(input.id, input);
                input.addEventListener('midimessage', (e) => this.onMIDIMessage(e));
            }
            
            // Setup outputs
            for (let output of this.midi.access.outputs.values()) {
                this.midi.outputs.set(output.id, output);
            }
            
            // Update MIDI device dropdown
            this.updateMIDIDeviceList();
        }
        
        /**
         * Handle MIDI state changes
         */
        onMIDIStateChange(e) {
            console.log('üéõÔ∏è MIDI device state changed:', e.port.name, e.port.state);
            
            if (e.port.type === 'input') {
                if (e.port.state === 'connected') {
                    this.midi.inputs.set(e.port.id, e.port);
                    e.port.addEventListener('midimessage', (e) => this.onMIDIMessage(e));
                } else {
                    this.midi.inputs.delete(e.port.id);
                }
            } else if (e.port.type === 'output') {
                if (e.port.state === 'connected') {
                    this.midi.outputs.set(e.port.id, e.port);
                } else {
                    this.midi.outputs.delete(e.port.id);
                }
            }
            
            this.updateMIDIDeviceList();
        }
        
        /**
         * Handle MIDI messages
         */
        onMIDIMessage(e) {
            const [command, note, velocity] = e.data;
            
            // Note on (144-159)
            if (command >= 144 && command <= 159) {
                if (velocity > 0) {
                    const noteName = this.midiToNote(note);
                    this.pressKey(noteName, velocity / 127);
                } else {
                    // Velocity 0 = note off
                    const noteName = this.midiToNote(note);
                    this.releaseKey(noteName);
                }
            }
            // Note off (128-143)
            else if (command >= 128 && command <= 143) {
                const noteName = this.midiToNote(note);
                this.releaseKey(noteName);
            }
        }
        
        /**
         * Update MIDI device list in settings
         */
        updateMIDIDeviceList() {
            const midiSelect = document.getElementById('srtMidiInput');
            if (!midiSelect) return;
            
            midiSelect.innerHTML = '<option value="">No MIDI device connected</option>';
            
            this.midi.inputs.forEach((input) => {
                const option = document.createElement('option');
                option.value = input.id;
                option.textContent = input.name;
                midiSelect.appendChild(option);
            });
            
            // Update MIDI button
            const midiBtn = document.getElementById('srtMidiBtn');
            if (midiBtn) {
                const connected = this.midi.inputs.size > 0;
                midiBtn.classList.toggle('srt-midi-connected', connected);
                midiBtn.querySelector('span').textContent = connected ? 'MIDI Connected' : 'Connect MIDI';
            }
        }
        
        /**
         * Initialize controls and toolbar
         */
        initializeControls() {
            console.log('üéõÔ∏è Initializing controls...');
            
            // Initialize all sliders and controls
            this.initializeTempoControl();
            this.initializeVolumeControl();
            this.initializeModeSelector();
            this.initializeDifficultySelector();
            this.initializeMetronome();
            this.initializeNoteNamesToggle();
            this.initializeOctaveSelector();
            this.initializeSoundSelector();
            
            console.log('‚úÖ Controls initialized');
        }
        
        /**
         * Initialize tempo control
         */
        initializeTempoControl() {
            const tempoSlider = document.getElementById('srtTempoSlider');
            const tempoValue = document.getElementById('srtTempoValue');
            
            if (tempoSlider && tempoValue) {
                tempoSlider.addEventListener('input', (e) => {
                    const tempo = parseInt(e.target.value);
                    this.setTempo(tempo);
                    tempoValue.textContent = tempo;
                });
                
                // Set initial value
                tempoSlider.value = this.gameState.tempo;
                tempoValue.textContent = this.gameState.tempo;
            }
        }
        
        /**
         * Initialize volume control - IDENTIQUE AU DESIGN TEMPO
         */
        initializeVolumeControl() {
            const volumeSlider = document.getElementById('srtVolumeSlider');
            const volumeValue = document.getElementById('srtVolumeValue');
            
            if (volumeSlider && volumeValue) {
                volumeSlider.addEventListener('input', (e) => {
                    const volume = parseInt(e.target.value) / 100;
                    this.setVolume(volume);
                    volumeValue.textContent = Math.round(volume * 100);
                });
                
                // Set initial value
                volumeSlider.value = Math.round(this.audio.volume * 100);
                volumeValue.textContent = Math.round(this.audio.volume * 100);
            }
        }
        
        /**
         * Initialize mode selector
         */
        initializeModeSelector() {
            const modeButtons = document.querySelectorAll('.srt-mode-btn');
            
            modeButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    const mode = e.target.dataset.mode;
                    this.setMode(mode);
                    
                    // Update active state
                    modeButtons.forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                });
            });
        }
        
        /**
         * Initialize difficulty selector
         */
        initializeDifficultySelector() {
            const difficultySelect = document.getElementById('srtDifficultySelect');
            
            if (difficultySelect) {
                difficultySelect.addEventListener('change', (e) => {
                    this.setDifficulty(e.target.value);
                });
                
                // Set initial value
                difficultySelect.value = this.gameState.difficulty;
            }
        }
        
        /**
         * Initialize metronome
         */
        initializeMetronome() {
            const metronomeBtn = document.getElementById('srtMetronomeBtn');
            
            if (metronomeBtn) {
                metronomeBtn.addEventListener('click', (e) => {
                    this.toggleMetronome();
                    e.target.classList.toggle('active', this.metronome.enabled);
                });
            }
        }
        
        /**
         * Initialize note names toggle - FONCTIONNEL ET SYNCHRONIS√â
         */
        initializeNoteNamesToggle() {
            const pianoNoteNames = document.getElementById('srtPianoNoteNames');
            const settingsNoteNames = document.getElementById('srtDisplayNotes');
            
            const toggleNoteNames = (checked) => {
                this.settings.displayNotes = checked;
                this.piano.showNoteNames = checked;
                
                // Update both checkboxes
                if (pianoNoteNames) pianoNoteNames.checked = checked;
                if (settingsNoteNames) settingsNoteNames.checked = checked;
                
                // Regenerate piano to show/hide note names
                const keyboardContainer = document.getElementById('srtPianoKeyboard');
                if (keyboardContainer) {
                    this.generatePianoKeys(keyboardContainer);
                    this.bindPianoEvents();
                }
                
                this.saveUserSetting('displayNotes', checked);
            };
            
            if (pianoNoteNames) {
                pianoNoteNames.addEventListener('change', (e) => {
                    toggleNoteNames(e.target.checked);
                });
            }
            
            if (settingsNoteNames) {
                settingsNoteNames.addEventListener('change', (e) => {
                    toggleNoteNames(e.target.checked);
                });
            }
        }
        
        /**
         * Initialize octave selector
         */
        initializeOctaveSelector() {
            const octaveSelect = document.getElementById('srtOctaveSelect');
            
            if (octaveSelect) {
                octaveSelect.addEventListener('change', (e) => {
                    const octaves = parseInt(e.target.value);
                    this.setOctaveCount(octaves);
                });
                
                // Set initial value
                octaveSelect.value = this.piano.octaves;
            }
        }
        
        /**
         * Initialize sound selector
         */
        initializeSoundSelector() {
            const soundSelect = document.getElementById('srtSoundSelect');
            
            if (soundSelect) {
                soundSelect.addEventListener('change', (e) => {
                    this.setSoundPack(e.target.value);
                });
                
                // Set initial value
                soundSelect.value = this.settings.soundPack;
            }
        }
        
        /**
         * Initialize panels (settings and statistics)
         */
        initializePanels() {
            console.log('üìä Initializing panels...');
            
            // Settings panel
            const settingsBtn = document.getElementById('srtSettingsBtn');
            const settingsPanel = document.getElementById('srtSettingsPanel');
            const settingsClose = document.getElementById('srtSettingsPanelClose');
            
            if (settingsBtn && settingsPanel) {
                settingsBtn.addEventListener('click', (e) => {
                    this.togglePanel('settings');
                });
                
                if (settingsClose) {
                    settingsClose.addEventListener('click', (e) => {
                        this.closePanel('settings');
                    });
                }
            }
            
            // Statistics panel
            const statsBtn = document.getElementById('srtStatsBtn');
            const statsPanel = document.getElementById('srtStatisticsPanel');
            const statsClose = document.getElementById('srtStatisticsPanelClose');
            
            if (statsBtn && statsPanel) {
                statsBtn.addEventListener('click', (e) => {
                    this.togglePanel('statistics');
                });
                
                if (statsClose) {
                    statsClose.addEventListener('click', (e) => {
                        this.closePanel('statistics');
                    });
                }
            }
            
            this.initializeSettingsPanelControls();
            
            console.log('‚úÖ Panels initialized');
        }
        
        /**
         * Initialize settings panel controls
         */
        initializeSettingsPanelControls() {
            // Staff type buttons
            const staffButtons = document.querySelectorAll('.srt-staff-btn');
            staffButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    const staffType = e.target.dataset.staff;
                    this.setStaffType(staffType);
                    
                    staffButtons.forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                });
            });
            
            // Generator type buttons
            const generatorButtons = document.querySelectorAll('.srt-generator-btn');
            generatorButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    const generatorType = e.target.dataset.generator;
                    this.setGeneratorType(generatorType);
                    
                    generatorButtons.forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                });
            });
            
            // Key signature buttons
            const keyButtons = document.querySelectorAll('.srt-key-btn');
            keyButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    const key = e.target.dataset.key;
                    this.setKeySignature(key);
                    
                    keyButtons.forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                });
            });
            
            // Range sliders
            this.initializeSlider('srtNotesSlider', 'srtNotesValue', (value) => {
                this.settings.notesCount = value;
                this.generateNotes();
            });
            
            this.initializeSlider('srtHandsSlider', 'srtHandsValue', (value) => {
                this.settings.handsCount = value;
                this.generateNotes();
            });
            
            this.initializeSlider('srtSmoothnessSlider', 'srtSmoothnessValue', (value) => {
                this.settings.smoothness = value;
                this.generateNotes();
            });
            
            // Notation system selector
            const notationSelect = document.getElementById('srtNotationSystem');
            if (notationSelect) {
                notationSelect.addEventListener('change', (e) => {
                    this.setNotationSystem(e.target.value);
                });
            }
        }
        
        /**
         * Initialize a range slider with callback
         */
        initializeSlider(sliderId, valueId, callback) {
            const slider = document.getElementById(sliderId);
            const valueElement = document.getElementById(valueId);
            
            if (slider && valueElement) {
                slider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    valueElement.textContent = value;
                    if (callback) callback(value);
                });
                
                // Set initial value
                valueElement.textContent = slider.value;
                if (callback) callback(parseInt(slider.value));
            }
        }
        
        /**
         * Initialize keyboard input
         */
        initializeKeyboardInput() {
            console.log('‚å®Ô∏è Initializing keyboard input...');
            
            // Map keyboard keys to piano notes
            this.keyboardMap = {
                'a': 'C4', 's': 'D4', 'd': 'E4', 'f': 'F4', 'g': 'G4', 'h': 'A4', 'j': 'B4', 'k': 'C5', 'l': 'D5',
                'w': 'C#4', 'e': 'D#4', 't': 'F#4', 'y': 'G#4', 'u': 'A#4', 'o': 'C#5', 'p': 'D#5'
            };
            
            this.pressedKeys = new Set();
            this.sustainPressed = false;
            
            document.addEventListener('keydown', (e) => {
                if (e.repeat) return;
                
                const key = e.key.toLowerCase();
                
                // Handle sustain (ALT key)
                if (key === 'alt') {
                    e.preventDefault();
                    this.sustainPressed = true;
                    return;
                }
                
                // Handle piano keys
                if (this.keyboardMap[key] && !this.pressedKeys.has(key)) {
                    e.preventDefault();
                    this.pressedKeys.add(key);
                    const note = this.keyboardMap[key];
                    this.pressKey(note, 0.8);
                }
                
                // Handle spacebar for play/pause
                if (key === ' ') {
                    e.preventDefault();
                    this.togglePlayPause();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                
                // Handle sustain release
                if (key === 'alt') {
                    e.preventDefault();
                    this.sustainPressed = false;
                    if (!this.sustainPressed) {
                        this.releaseAllKeys();
                    }
                    return;
                }
                
                // Handle piano key release
                if (this.keyboardMap[key] && this.pressedKeys.has(key)) {
                    e.preventDefault();
                    this.pressedKeys.delete(key);
                    if (!this.sustainPressed) {
                        const note = this.keyboardMap[key];
                        this.releaseKey(note);
                    }
                }
            });
            
            console.log('‚úÖ Keyboard input initialized');
        }
        
        /**
         * Bind all event handlers
         */
        bindEvents() {
            console.log('üîó Binding events...');
            
            // Main control buttons
            const playBtn = document.getElementById('srtPlayBtn');
            const pauseBtn = document.getElementById('srtPauseBtn');
            const stopBtn = document.getElementById('srtStopBtn');
            const resetBtn = document.getElementById('srtResetBtn');
            
            if (playBtn) playBtn.addEventListener('click', () => this.play());
            if (pauseBtn) pauseBtn.addEventListener('click', () => this.pause());
            if (stopBtn) stopBtn.addEventListener('click', () => this.stop());
            if (resetBtn) resetBtn.addEventListener('click', () => this.reset());
            
            // Window events
            window.addEventListener('blur', () => {
                // Release all keys when window loses focus
                this.releaseAllKeys();
            });
            
            // Handle orientation change for mobile
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    this.resizeCanvas();
                    this.checkOrientation();
                }, 100);
            });
            
            this.checkOrientation();
            
            console.log('‚úÖ Events bound');
        }
        
        /**
         * Check device orientation and show notice if needed
         */
        checkOrientation() {
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const orientationNotice = document.getElementById('srtOrientationNotice');
            
            if (isMobile && orientationNotice) {
                const isPortrait = window.innerHeight > window.innerWidth;
                orientationNotice.style.display = isPortrait ? 'flex' : 'none';
            }
        }
        
        /**
         * Load user settings
         */
        async loadUserSettings() {
            console.log('‚öôÔ∏è Loading user settings...');
            
            // Load settings from server or localStorage
            try {
                if (this.config.userSettings) {
                    Object.assign(this.settings, this.config.userSettings);
                    this.applyLoadedSettings();
                }
            } catch (error) {
                console.error('‚ùå Failed to load user settings:', error);
            }
            
            console.log('‚úÖ User settings loaded');
        }
        
        /**
         * Apply loaded settings to UI
         */
        applyLoadedSettings() {
            // Apply staff type
            if (this.settings.staff_type) {
                this.setStaffType(this.settings.staff_type);
            }
            
            // Apply difficulty
            if (this.settings.difficulty) {
                this.setDifficulty(this.settings.difficulty);
            }
            
            // Apply tempo
            if (this.settings.tempo) {
                this.setTempo(this.settings.tempo);
            }
            
            // Apply volume
            if (this.settings.volume !== undefined) {
                this.setVolume(this.settings.volume);
            }
            
            // Apply notation system
            if (this.settings.notationSystem) {
                this.setNotationSystem(this.settings.notationSystem);
            }
            
            // Apply note names display
            if (this.settings.displayNotes !== undefined) {
                this.settings.displayNotes = this.settings.displayNotes;
                this.piano.showNoteNames = this.settings.displayNotes;
            }
        }
        
        /**
         * Save user setting
         */
        saveUserSetting(key, value) {
            // Save to server if user is logged in
            if (this.config.user_id > 0) {
                // TODO: Implement server-side saving
            }
            
            // Save to localStorage as backup
            try {
                const settings = JSON.parse(localStorage.getItem('srt_settings') || '{}');
                settings[key] = value;
                localStorage.setItem('srt_settings', JSON.stringify(settings));
            } catch (error) {
                console.error('Failed to save setting to localStorage:', error);
            }
        }
        
        /**
         * Generate notes based on current settings
         */
        generateNotes() {
            console.log('üéµ Generating notes...');
            
            this.music.generatedNotes = [];
            this.music.currentNoteIndex = 0;
            
            // Use chord generator based on difficulty and settings
            if (window.SightReadingChordGenerator) {
                const generator = new window.SightReadingChordGenerator(this.config);
                this.music.generatedNotes = generator.generate({
                    difficulty: this.gameState.difficulty,
                    count: 50, // Generate 50 notes ahead
                    keySignature: this.gameState.keySignature,
                    noteRange: this.settings.noteRange,
                    notesCount: this.settings.notesCount,
                    generatorType: this.settings.generatorType,
                    timeSignature: this.gameState.timeSignature
                });
            } else {
                // Fallback simple note generation
                this.generateSimpleNotes();
            }
            
            console.log(`‚úÖ Generated ${this.music.generatedNotes.length} notes`);
        }
        
        /**
         * Fallback simple note generation
         */
        generateSimpleNotes() {
            const notes = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
            const octaves = [3, 4, 5];
            
            for (let i = 0; i < 50; i++) {
                const note = notes[Math.floor(Math.random() * notes.length)];
                const octave = octaves[Math.floor(Math.random() * octaves.length)];
                
                this.music.generatedNotes.push({
                    notes: [note + octave],
                    duration: '4n',
                    x: 150 + (i * 80),
                    staff: octave >= 4 ? 'treble' : 'bass',
                    measure: Math.floor(i / 4),
                    beat: i % 4
                });
            }
        }
        
        /**
         * Start rendering loop
         */
        startRendering() {
            console.log('üé¨ Starting render loop...');
            
            this.animation.running = true;
            this.renderLoop();
            
            console.log('‚úÖ Render loop started');
        }
        
        /**
         * Main render loop
         */
        renderLoop = (timestamp) => {
            if (!this.animation.running) return;
            
            // Calculate delta time
            this.animation.deltaTime = timestamp - this.animation.lastTime;
            this.animation.lastTime = timestamp;
            
            // Update game state
            this.update(this.animation.deltaTime);
            
            // Render everything
            this.render();
            
            // Continue loop
            this.animation.frame = requestAnimationFrame(this.renderLoop);
        };
        
        /**
         * Update game logic
         */
        update(deltaTime) {
            // Update scroll position in scroll mode
            if (this.gameState.mode === 'scroll' && this.gameState.isPlaying) {
                this.music.scrollSpeed = (this.gameState.tempo / 120) * 0.5;
                
                // Move notes to the left
                this.music.generatedNotes.forEach(note => {
                    note.x -= this.music.scrollSpeed * (deltaTime / 16);
                });
                
                // Remove notes that have scrolled off screen
                this.music.generatedNotes = this.music.generatedNotes.filter(note => note.x > -100);
                
                // Generate new notes if needed
                if (this.music.generatedNotes.length < 20) {
                    this.generateMoreNotes();
                }
            }
            
            // Update metronome
            if (this.metronome.enabled && this.gameState.isPlaying) {
                this.updateMetronome(deltaTime);
            }
            
            // Update statistics
            this.updateStatistics(deltaTime);
            
            // Update played notes (fade out over time)
            this.updatePlayedNotes(deltaTime);
        }
        
        /**
         * Generate more notes for continuous play
         */
        generateMoreNotes() {
            const lastNote = this.music.generatedNotes[this.music.generatedNotes.length - 1];
            const startX = lastNote ? lastNote.x + 80 : 200;
            
            for (let i = 0; i < 10; i++) {
                // Simple note generation for now
                const notes = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
                const octaves = [3, 4, 5];
                const note = notes[Math.floor(Math.random() * notes.length)];
                const octave = octaves[Math.floor(Math.random() * octaves.length)];
                
                this.music.generatedNotes.push({
                    notes: [note + octave],
                    duration: '4n',
                    x: startX + (i * 80),
                    staff: octave >= 4 ? 'treble' : 'bass',
                    measure: 0,
                    beat: 0
                });
            }
        }
        
        /**
         * Update metronome
         */
        updateMetronome(deltaTime) {
            this.metronome.beatInterval = (60 / this.gameState.tempo) * 1000;
            
            if (Date.now() >= this.metronome.nextBeatTime) {
                this.playMetronomeBeat();
                this.metronome.beat = (this.metronome.beat + 1) % 4;
                this.metronome.nextBeatTime = Date.now() + this.metronome.beatInterval;
            }
        }
        
        /**
         * Update statistics display
         */
        updateStatistics(deltaTime) {
            if (this.gameState.isPlaying && this.stats.sessionStartTime) {
                this.stats.sessionDuration = Date.now() - this.stats.sessionStartTime;
            }
            
            // Calculate accuracy
            if (this.stats.totalNotes > 0) {
                this.stats.accuracy = Math.round((this.stats.correctNotes / this.stats.totalNotes) * 100);
            }
            
            // Update UI elements
            this.updateStatisticsUI();
        }
        
        /**
         * Update statistics UI
         */
        updateStatisticsUI() {
            const elements = {
                correct: document.getElementById('srtStatCorrect'),
                incorrect: document.getElementById('srtStatIncorrect'),
                accuracy: document.getElementById('srtStatAccuracy'),
                streak: document.getElementById('srtStatStreak'),
                bestStreak: document.getElementById('srtStatBestStreak'),
                time: document.getElementById('srtStatTime')
            };
            
            if (elements.correct) elements.correct.textContent = this.stats.correctNotes;
            if (elements.incorrect) elements.incorrect.textContent = this.stats.incorrectNotes;
            if (elements.accuracy) elements.accuracy.textContent = this.stats.accuracy + '%';
            if (elements.streak) elements.streak.textContent = this.stats.streak;
            if (elements.bestStreak) elements.bestStreak.textContent = this.stats.bestStreak;
            if (elements.time) {
                const minutes = Math.floor(this.stats.sessionDuration / 60000);
                const seconds = Math.floor((this.stats.sessionDuration % 60000) / 1000);
                elements.time.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }
        
        /**
         * Update played notes (fade out effect)
         */
        updatePlayedNotes(deltaTime) {
            this.music.playedNotes.forEach((noteData, noteId) => {
                noteData.opacity -= deltaTime * 0.002;
                if (noteData.opacity <= 0) {
                    this.music.playedNotes.delete(noteId);
                }
            });
        }
        
        /**
         * Main render function
         */
        render() {
            // Clear canvas
            this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
            
            // Draw staff
            this.drawStaff();
            
            // Draw notes
            this.drawNotes();
            
            // Draw played notes
            this.drawPlayedNotes();
            
            // Draw playhead in scroll mode
            if (this.gameState.mode === 'scroll') {
                this.drawPlayhead();
            }
            
            // Draw feedback
            this.drawFeedback();
        }
        
        /**
         * Draw musical staff - GRAND STAFF PAR D√âFAUT
         */
        drawStaff() {
            const ctx = this.ctx;
            const margin = this.staffSettings.marginLeft;
            const top = this.staffSettings.marginTop;
            const lineHeight = this.staffSettings.lineHeight;
            const staffHeight = this.staffSettings.staffHeight;
            const grandStaffGap = this.staffSettings.grandStaffGap;
            
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            
            // Draw staff based on type
            if (this.staffSettings.type === 'grand' || this.staffSettings.showGrandStaff) {
                // Draw treble staff (top)
                this.drawSingleStaff(margin, top, 'treble');
                
                // Draw bass staff (bottom)
                this.drawSingleStaff(margin, top + staffHeight + grandStaffGap, 'bass');
                
                // Draw grand staff brace
                this.drawGrandStaffBrace(margin - 30, top, staffHeight + grandStaffGap);
            } else {
                // Draw single staff
                this.drawSingleStaff(margin, top, this.staffSettings.type);
            }
            
            // Draw key signature
            this.drawKeySignature();
            
            // Draw time signature
            this.drawTimeSignature();
        }
        
        /**
         * Draw a single staff
         */
        drawSingleStaff(x, y, clef) {
            const ctx = this.ctx;
            const staffWidth = this.canvasWidth - x - 50;
            const lineHeight = this.staffSettings.lineHeight;
            
            // Draw staff lines
            for (let i = 0; i < 5; i++) {
                const lineY = y + (i * lineHeight);
                ctx.beginPath();
                ctx.moveTo(x, lineY);
                ctx.lineTo(x + staffWidth, lineY);
                ctx.stroke();
            }
            
            // Draw clef
            this.drawClef(x + 10, y, clef);
        }
        
        /**
         * Draw clef symbol
         */
        drawClef(x, y, clef) {
            const ctx = this.ctx;
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 36px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const clefY = y + (this.staffSettings.lineHeight * 2); // Center on staff
            
            if (clef === 'treble') {
                ctx.fillText('ùÑû', x, clefY);
            } else if (clef === 'bass') {
                ctx.fillText('ùÑ¢', x, clefY);
            } else if (clef === 'alto') {
                ctx.fillText('ùÑ°', x, clefY);
            }
        }
        
        /**
         * Draw grand staff brace
         */
        drawGrandStaffBrace(x, y, height) {
            const ctx = this.ctx;
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            
            // Draw brace (simplified as a curved line)
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.quadraticCurveTo(x - 15, y + height / 2, x, y + height);
            ctx.stroke();
            
            // Draw connecting line
            ctx.beginPath();
            ctx.moveTo(x + 5, y);
            ctx.lineTo(x + 5, y + height);
            ctx.stroke();
        }
        
        /**
         * Draw key signature
         */
        drawKeySignature() {
            const ctx = this.ctx;
            const keySignature = this.gameState.keySignature;
            
            if (keySignature === 'C') return; // No sharps or flats
            
            const margin = this.staffSettings.marginLeft + 50;
            const top = this.staffSettings.marginTop;
            const lineHeight = this.staffSettings.lineHeight;
            const staffHeight = this.staffSettings.staffHeight;
            const grandStaffGap = this.staffSettings.grandStaffGap;
            
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 20px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Key signature mapping (simplified)
            const keySignatures = {
                'G': ['‚ôØ'], 'D': ['‚ôØ', '‚ôØ'], 'A': ['‚ôØ', '‚ôØ', '‚ôØ'], 'E': ['‚ôØ', '‚ôØ', '‚ôØ', '‚ôØ'],
                'F': ['‚ô≠'], 'Bb': ['‚ô≠', '‚ô≠'], 'Eb': ['‚ô≠', '‚ô≠', '‚ô≠'], 'Ab': ['‚ô≠', '‚ô≠', '‚ô≠', '‚ô≠']
            };
            
            const accidentals = keySignatures[keySignature] || [];
            
            accidentals.forEach((accidental, index) => {
                const x = margin + (index * 12);
                
                // Draw on treble staff
                if (this.staffSettings.type === 'grand' || this.staffSettings.type === 'treble') {
                    ctx.fillText(accidental, x, top + lineHeight);
                }
                
                // Draw on bass staff
                if (this.staffSettings.type === 'grand' || this.staffSettings.type === 'bass') {
                    ctx.fillText(accidental, x, top + staffHeight + grandStaffGap + lineHeight);
                }
            });
        }
        
        /**
         * Draw time signature
         */
        drawTimeSignature() {
            const ctx = this.ctx;
            const timeSignature = this.gameState.timeSignature;
            const [numerator, denominator] = timeSignature.split('/');
            
            const margin = this.staffSettings.marginLeft + 80;
            const top = this.staffSettings.marginTop;
            const lineHeight = this.staffSettings.lineHeight;
            const staffHeight = this.staffSettings.staffHeight;
            const grandStaffGap = this.staffSettings.grandStaffGap;
            
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 20px arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Draw on treble staff
            if (this.staffSettings.type === 'grand' || this.staffSettings.type === 'treble') {
                ctx.fillText(numerator, margin, top + lineHeight);
                ctx.fillText(denominator, margin, top + (lineHeight * 3));
            }
            
            // Draw on bass staff
            if (this.staffSettings.type === 'grand' || this.staffSettings.type === 'bass') {
                const bassY = top + staffHeight + grandStaffGap;
                ctx.fillText(numerator, margin, bassY + lineHeight);
                ctx.fillText(denominator, margin, bassY + (lineHeight * 3));
            }
        }
        
        /**
         * Draw notes on staff
         */
        drawNotes() {
            const ctx = this.ctx;
            
            this.music.generatedNotes.forEach((noteData, index) => {
                if (noteData.x > -50 && noteData.x < this.canvasWidth + 50) {
                    this.drawNote(noteData, index);
                }
            });
        }
        
        /**
         * Draw a single note
         */
        drawNote(noteData, index) {
            const ctx = this.ctx;
            const notes = noteData.notes;
            const x = noteData.x;
            const isCorrect = index === this.music.currentNoteIndex && this.gameState.mode === 'wait';
            
            notes.forEach((note, noteIndex) => {
                const { staff, line } = this.getNotePosition(note);
                const y = this.getStaffY(staff) + (line * (this.staffSettings.lineHeight / 2));
                
                // Draw note head
                ctx.fillStyle = isCorrect ? '#C59D3A' : '#000000';
                ctx.beginPath();
                ctx.ellipse(x, y, 6, 4, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw stem
                if (noteData.duration !== 'whole') {
                    ctx.strokeStyle = ctx.fillStyle;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + 6, y);
                    ctx.lineTo(x + 6, y - 25);
                    ctx.stroke();
                }
                
                // Draw ledger lines if needed
                this.drawLedgerLines(x, y, staff, line);
                
                // Draw note name if enabled
                if (this.settings.displayNotes) {
                    this.drawNoteName(x, y + 25, note);
                }
            });
        }
        
        /**
         * Get note position on staff
         */
        getNotePosition(note) {
            const noteRegex = /([A-G][b#]?)(\d+)/;
            const match = note.match(noteRegex);
            
            if (!match) return { staff: 'treble', line: 0 };
            
            const noteName = match[1];
            const octave = parseInt(match[2]);
            
            // Determine staff based on octave
            let staff;
            if (this.staffSettings.type === 'grand') {
                staff = octave >= 4 ? 'treble' : 'bass';
            } else {
                staff = this.staffSettings.type;
            }
            
            // Calculate line position (0 = bottom line, 4 = top line, negative = below, positive above)
            const noteOrder = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
            const noteIndex = noteOrder.indexOf(noteName.charAt(0));
            
            let line;
            if (staff === 'treble') {
                // Treble clef: E4 is on bottom line (line 0)
                const referenceNote = 'E';
                const referenceOctave = 4;
                const referenceLine = 0;
                
                const octaveDiff = octave - referenceOctave;
                const noteDiff = noteIndex - noteOrder.indexOf(referenceNote);
                
                line = referenceLine + (octaveDiff * 7) + noteDiff;
            } else {
                // Bass clef: G2 is on bottom line (line 0)
                const referenceNote = 'G';
                const referenceOctave = 2;
                const referenceLine = 0;
                
                const octaveDiff = octave - referenceOctave;
                const noteDiff = noteIndex - noteOrder.indexOf(referenceNote);
                
                line = referenceLine + (octaveDiff * 7) + noteDiff;
            }
            
            return { staff, line };
        }
        
        /**
         * Get Y position of staff
         */
        getStaffY(staff) {
            const top = this.staffSettings.marginTop;
            const staffHeight = this.staffSettings.staffHeight;
            const grandStaffGap = this.staffSettings.grandStaffGap;
            const lineHeight = this.staffSettings.lineHeight;
            
            if (staff === 'treble' || (staff === 'single' && this.staffSettings.type === 'treble')) {
                return top + (lineHeight * 4); // Bottom line of treble staff
            } else if (staff === 'bass') {
                return top + staffHeight + grandStaffGap + (lineHeight * 4); // Bottom line of bass staff
            }
            
            return top + (lineHeight * 4);
        }
        
        /**
         * Draw ledger lines for notes outside staff
         */
        drawLedgerLines(x, y, staff, line) {
            const ctx = this.ctx;
            const staffY = this.getStaffY(staff);
            const lineHeight = this.staffSettings.lineHeight / 2;
            
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            
            // Draw ledger lines below staff
            if (line < 0) {
                for (let i = -1; i >= line; i--) {
                    if (i % 2 === 1) { // Only on odd lines (ledger line positions)
                        const ledgerY = staffY - (i * lineHeight);
                        ctx.beginPath();
                        ctx.moveTo(x - 10, ledgerY);
                        ctx.lineTo(x + 10, ledgerY);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw ledger lines above staff
            if (line > 8) {
                for (let i = 9; i <= line; i++) {
                    if (i % 2 === 1) { // Only on odd lines (ledger line positions)
                        const ledgerY = staffY - (i * lineHeight);
                        ctx.beginPath();
                        ctx.moveTo(x - 10, ledgerY);
                        ctx.lineTo(x + 10, ledgerY);
                        ctx.stroke();
                    }
                }
            }
        }
        
        /**
         * Draw note name
         */
        drawNoteName(x, y, note) {
            const ctx = this.ctx;
            const noteName = this.getNoteInNotation(note, this.settings.notationSystem);
            
            ctx.fillStyle = '#666666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(noteName, x, y);
        }
        
        /**
         * Draw played notes on staff - NOTES JOU√âES S'AFFICHENT
         */
        drawPlayedNotes() {
            const ctx = this.ctx;
            
            this.music.playedNotes.forEach((noteData, noteId) => {
                const note = noteData.note;
                const isCorrect = noteData.correct;
                const opacity = noteData.opacity;
                
                const { staff, line } = this.getNotePosition(note);
                const x = noteData.x || (this.staffSettings.marginLeft + 120); // First measure
                const y = this.getStaffY(staff) + (line * (this.staffSettings.lineHeight / 2));
                
                // Set color and opacity based on correctness
                ctx.globalAlpha = opacity;
                ctx.fillStyle = isCorrect ? '#4CAF50' : 'rgba(244, 67, 54, 0.7)';
                
                // Draw note head
                ctx.beginPath();
                ctx.ellipse(x, y, 6, 4, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw stem
                ctx.strokeStyle = ctx.fillStyle;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x + 6, y);
                ctx.lineTo(x + 6, y - 25);
                ctx.stroke();
                
                // Draw ledger lines if needed
                this.drawLedgerLines(x, y, staff, line);
                
                // Draw note name if enabled
                if (this.settings.displayNotes) {
                    ctx.fillStyle = isCorrect ? '#2E7D32' : '#C62828';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const noteName = this.getNoteInNotation(note, this.settings.notationSystem);
                    ctx.fillText(noteName, x, y + 25);
                }
                
                ctx.globalAlpha = 1; // Reset alpha
            });
        }
        
        /**
         * Draw playhead in scroll mode - BANDE VERTICALE FIXE
         */
        drawPlayhead() {
            const ctx = this.ctx;
            const x = this.music.playheadPosition;
            
            // Draw playhead line
            ctx.strokeStyle = 'rgba(197, 157, 58, 0.8)'; // Gold with transparency
            ctx.lineWidth = 10;
            ctx.beginPath();
            ctx.moveTo(x, this.staffSettings.marginTop - 10);
            ctx.lineTo(x, this.staffSettings.marginTop + 200);
            ctx.stroke();
            
            // Add glow effect
            ctx.strokeStyle = 'rgba(197, 157, 58, 0.3)';
            ctx.lineWidth = 20;
            ctx.stroke();
        }
        
        /**
         * Draw feedback messages
         */
        drawFeedback() {
            // Feedback is handled in HTML overlay for better styling
        }
        
        // =================== GAME CONTROL METHODS ===================
        
        /**
         * Start/Resume the game
         */
        play() {
            this.gameState.isPlaying = true;
            this.gameState.isPaused = false;
            
            if (!this.stats.sessionStartTime) {
                this.stats.sessionStartTime = Date.now();
            }
            
            // Activate audio context if needed
            this.activateAudio();
            
            // Update UI
            this.updatePlayButtons();
            
            console.log('‚ñ∂Ô∏è Game started');
        }
        
        /**
         * Pause the game
         */
        pause() {
            this.gameState.isPlaying = false;
            this.gameState.isPaused = true;
            
            // Update UI
            this.updatePlayButtons();
            
            console.log('‚è∏Ô∏è Game paused');
        }
        
        /**
         * Stop the game
         */
        stop() {
            this.gameState.isPlaying = false;
            this.gameState.isPaused = false;
            
            // Reset position
            this.music.currentNoteIndex = 0;
            
            // Update UI
            this.updatePlayButtons();
            
            console.log('‚èπÔ∏è Game stopped');
        }
        
        /**
         * Reset the game
         */
        reset() {
            this.stop();
            
            // Reset all statistics
            this.stats = {
                correctNotes: 0,
                incorrectNotes: 0,
                totalNotes: 0,
                streak: 0,
                bestStreak: 0,
                sessionStartTime: null,
                sessionDuration: 0,
                accuracy: 0
            };
            
            // Clear played notes
            this.music.playedNotes.clear();
            
            // Generate new notes
            this.generateNotes();
            
            // Update UI
            this.updateStatisticsUI();
            
            console.log('üîÑ Game reset');
        }
        
        /**
         * Toggle play/pause
         */
        togglePlayPause() {
            if (this.gameState.isPlaying) {
                this.pause();
            } else {
                this.play();
            }
        }
        
        /**
         * Update play button states
         */
        updatePlayButtons() {
            const playBtn = document.getElementById('srtPlayBtn');
            const pauseBtn = document.getElementById('srtPauseBtn');
            
            if (playBtn && pauseBtn) {
                if (this.gameState.isPlaying) {
                    playBtn.style.display = 'none';
                    pauseBtn.style.display = 'flex';
                } else {
                    playBtn.style.display = 'flex';
                    pauseBtn.style.display = 'none';
                }
            }
        }
        
        // =================== SETTING METHODS ===================
        
        /**
         * Set game mode
         */
        setMode(mode) {
            this.gameState.mode = mode;
            console.log(`üéÆ Mode set to: ${mode}`);
            
            // Reset game state when mode changes
            this.reset();
            
            this.saveUserSetting('mode', mode);
        }
        
        /**
         * Set difficulty
         */
        setDifficulty(difficulty) {
            this.gameState.difficulty = difficulty;
            console.log(`‚öôÔ∏è Difficulty set to: ${difficulty}`);
            
            // Apply difficulty settings
            const difficultySettings = this.config.difficulties[difficulty];
            if (difficultySettings) {
                this.settings.noteRange = {
                    min: difficultySettings.range[0],
                    max: difficultySettings.range[1]
                };
                this.settings.notesCount = difficultySettings.notes_count;
                this.staffSettings.showGrandStaff = difficultySettings.use_grand_staff;
                
                if (difficulty === 'beginner') {
                    this.staffSettings.type = 'treble';
                    this.staffSettings.showGrandStaff = false;
                } else {
                    this.staffSettings.type = 'grand';
                    this.staffSettings.showGrandStaff = true;
                }
            }
            
            // Regenerate notes with new difficulty
            this.generateNotes();
            
            this.saveUserSetting('difficulty', difficulty);
        }
        
        /**
         * Set tempo
         */
        setTempo(tempo) {
            this.gameState.tempo = Math.max(40, Math.min(200, tempo));
            console.log(`üéµ Tempo set to: ${this.gameState.tempo} BPM`);
            
            // Update metronome interval
            this.metronome.beatInterval = (60 / this.gameState.tempo) * 1000;
            
            this.saveUserSetting('tempo', this.gameState.tempo);
        }
        
        /**
         * Set staff type
         */
        setStaffType(staffType) {
            this.staffSettings.type = staffType;
            this.staffSettings.showGrandStaff = (staffType === 'grand');
            
            console.log(`üéº Staff type set to: ${staffType}`);
            
            // Regenerate notes for new staff
            this.generateNotes();
            
            this.saveUserSetting('staff_type', staffType);
        }
        
        /**
         * Set key signature
         */
        setKeySignature(key) {
            this.gameState.keySignature = key;
            console.log(`üéπ Key signature set to: ${key}`);
            
            // Regenerate notes with new key
            this.generateNotes();
            
            this.saveUserSetting('key_signature', key);
        }
        
        /**
         * Set generator type
         */
        setGeneratorType(type) {
            this.settings.generatorType = type;
            console.log(`üéØ Generator type set to: ${type}`);
            
            // Regenerate notes with new generator
            this.generateNotes();
            
            this.saveUserSetting('generator_type', type);
        }
        
        /**
         * Set notation system
         */
        setNotationSystem(system) {
            this.settings.notationSystem = system;
            console.log(`üåê Notation system set to: ${system}`);
            
            // Update piano key labels
            const keyboardContainer = document.getElementById('srtPianoKeyboard');
            if (keyboardContainer) {
                this.generatePianoKeys(keyboardContainer);
                this.bindPianoEvents();
            }
            
            // Update settings select
            const notationSelect = document.getElementById('srtNotationSystem');
            if (notationSelect) {
                notationSelect.value = system;
            }
            
            this.saveUserSetting('notation_system', system);
        }
        
        /**
         * Set octave count for piano
         */
        setOctaveCount(octaves) {
            this.piano.octaves = octaves;
            console.log(`üéπ Piano octaves set to: ${octaves}`);
            
            // Regenerate piano keys
            const keyboardContainer = document.getElementById('srtPianoKeyboard');
            if (keyboardContainer) {
                this.generatePianoKeys(keyboardContainer);
                this.bindPianoEvents();
            }
            
            this.saveUserSetting('octave_count', octaves);
        }
        
        /**
         * Set sound pack
         */
        setSoundPack(soundPack) {
            this.settings.soundPack = soundPack;
            console.log(`üîä Sound pack set to: ${soundPack}`);
            
            // TODO: Load different sound pack
            
            this.saveUserSetting('sound_pack', soundPack);
        }
        
        /**
         * Toggle metronome
         */
        toggleMetronome() {
            this.metronome.enabled = !this.metronome.enabled;
            console.log(`ü•Å Metronome ${this.metronome.enabled ? 'enabled' : 'disabled'}`);
            
            if (this.metronome.enabled) {
                this.metronome.nextBeatTime = Date.now();
                this.metronome.beat = 0;
            }
            
            this.saveUserSetting('metronome_enabled', this.metronome.enabled);
        }
        
        /**
         * Play metronome beat
         */
        playMetronomeBeat() {
            if (this.audio.metronome && this.audio.metronome.start) {
                try {
                    this.audio.metronome.start('+0');
                    
                    // Visual metronome feedback
                    const metronomeBtn = document.getElementById('srtMetronomeBtn');
                    if (metronomeBtn) {
                        metronomeBtn.classList.add('srt-metronome-pulse');
                        setTimeout(() => {
                            metronomeBtn.classList.remove('srt-metronome-pulse');
                        }, 100);
                    }
                } catch (error) {
                    console.error('Failed to play metronome beat:', error);
                }
            }
        }
        
        // =================== PANEL METHODS ===================
        
        /**
         * Toggle panel (settings or statistics)
         */
        togglePanel(panelType) {
            if (this.panels[panelType]) {
                this.closePanel(panelType);
            } else {
                this.openPanel(panelType);
            }
        }
        
        /**
         * Open panel
         */
        openPanel(panelType) {
            const panel = document.getElementById(`srt${panelType.charAt(0).toUpperCase() + panelType.slice(1)}Panel`);
            if (panel) {
                panel.classList.add('srt-panel-open');
                this.panels[panelType] = true;
                
                // Close other panels
                Object.keys(this.panels).forEach(otherType => {
                    if (otherType !== panelType && this.panels[otherType]) {
                        this.closePanel(otherType);
                    }
                });
                
                console.log(`üìä ${panelType} panel opened`);
            }
        }
        
        /**
         * Close panel
         */
        closePanel(panelType) {
            const panel = document.getElementById(`srt${panelType.charAt(0).toUpperCase() + panelType.slice(1)}Panel`);
            if (panel) {
                panel.classList.remove('srt-panel-open');
                this.panels[panelType] = false;
                
                console.log(`üìä ${panelType} panel closed`);
            }
        }
        
        // =================== PIANO INTERACTION METHODS ===================
        
        /**
         * Press a piano key
         */
        pressKey(note, velocity = 0.8) {
            // Play sound
            if (this.audio.piano && this.audio.piano.triggerAttack) {
                try {
                    this.audio.piano.triggerAttack(note, '+0', velocity);
                } catch (error) {
                    console.error('Failed to play note:', error);
                }
            }
            
            // Update key visual
            const key = this.piano.keys.get(note);
            if (key && key.element) {
                key.element.classList.add('active');
                key.pressed = true;
            }
            
            // Check if note is correct and handle game logic
            this.handleNoteInput(note);
            
            // Add played note to display - CORRECTION MAJEURE
            this.addPlayedNote(note);
            
            console.log(`üéµ Note pressed: ${note}`);
        }
        
        /**
         * Release a piano key
         */
        releaseKey(note) {
            // Stop sound
            if (this.audio.piano && this.audio.piano.triggerRelease) {
                try {
                    this.audio.piano.triggerRelease(note, '+0');
                } catch (error) {
                    console.error('Failed to release note:', error);
                }
            }
            
            // Update key visual
            const key = this.piano.keys.get(note);
            if (key && key.element) {
                key.element.classList.remove('active');
                key.pressed = false;
            }
            
            console.log(`üéµ Note released: ${note}`);
        }
        
        /**
         * Release all keys
         */
        releaseAllKeys() {
            this.piano.keys.forEach((key, note) => {
                if (key.pressed) {
                    this.releaseKey(note);
                }
            });
        }
        
        /**
         * Add played note to staff display
         */
        addPlayedNote(note) {
            const noteId = Date.now() + Math.random();
            const currentTargetNotes = this.getCurrentTargetNotes();
            const isCorrect = currentTargetNotes.includes(note);
            
            this.music.playedNotes.set(noteId, {
                note: note,
                correct: isCorrect,
                opacity: 1.0,
                timestamp: Date.now(),
                x: this.getPlayedNoteX()
            });
            
            // Remove after delay if incorrect
            if (!isCorrect) {
                setTimeout(() => {
                    this.music.playedNotes.delete(noteId);
                }, 1000);
            }
        }
        
        /**
         * Get X position for played notes
         */
        getPlayedNoteX() {
            if (this.gameState.mode === 'scroll') {
                return this.music.playheadPosition;
            } else {
                // First measure position
                return this.staffSettings.marginLeft + 120;
            }
        }
        
        /**
         * Get current target notes
         */
        getCurrentTargetNotes() {
            if (this.music.generatedNotes.length === 0) return [];
            
            const currentNote = this.music.generatedNotes[this.music.currentNoteIndex];
            return currentNote ? currentNote.notes : [];
        }
        
        /**
         * Handle note input (game logic)
         */
        handleNoteInput(note) {
            const targetNotes = this.getCurrentTargetNotes();
            const isCorrect = targetNotes.includes(note);
            
            this.stats.totalNotes++;
            
            if (isCorrect) {
                this.stats.correctNotes++;
                this.stats.streak++;
                
                if (this.stats.streak > this.stats.bestStreak) {
                    this.stats.bestStreak = this.stats.streak;
                }
                
                this.showFeedback('correct', 'Correct! üéµ');
                this.advanceToNextNote();
            } else {
                this.stats.incorrectNotes++;
                this.stats.streak = 0;
                
                this.showFeedback('incorrect', 'Try again üéØ');
                
                // In scroll mode, stop until correct
                if (this.gameState.mode === 'scroll') {
                    this.gameState.isPlaying = false;
                }
            }
            
            // Update statistics UI
            this.updateStatisticsUI();
        }
        
        /**
         * Advance to next note
         */
        advanceToNextNote() {
            if (this.gameState.mode === 'wait') {
                this.music.currentNoteIndex++;
                
                // Generate more notes if needed
                if (this.music.currentNoteIndex >= this.music.generatedNotes.length - 10) {
                    this.generateMoreNotes();
                }
            } else if (this.gameState.mode === 'scroll') {
                // Resume scrolling
                this.gameState.isPlaying = true;
            }
        }
        
        /**
         * Show feedback message
         */
        showFeedback(type, message) {
            const feedbackElement = document.getElementById('srtFeedback');
            if (feedbackElement) {
                feedbackElement.textContent = message;
                feedbackElement.className = `srt-feedback srt-feedback-${type}`;
                
                // Auto-hide after delay
                setTimeout(() => {
                    feedbackElement.className = 'srt-feedback';
                    feedbackElement.textContent = '';
                }, 1500);
            }
        }
        
        /**
         * Show error message
         */
        showError(message) {
            console.error('‚ùå', message);
            alert(message); // Simple error display for now
        }
        
        // =================== UTILITY METHODS ===================
        
        /**
         * Convert MIDI note number to note name
         */
        midiToNote(midiNote) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const octave = Math.floor(midiNote / 12) - 1;
            const noteName = noteNames[midiNote % 12];
            return noteName + octave;
        }
        
        /**
         * Convert note name to MIDI note number
         */
        noteToMidi(note) {
            const noteRegex = /([A-G][b#]?)(\d+)/;
            const match = note.match(noteRegex);
            
            if (!match) return 60; // Default to C4
            
            const [, noteName, octave] = match;
            const octaveNum = parseInt(octave);
            
            const noteMap = {
                'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
                'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,
                'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
            };
            
            return (octaveNum + 1) * 12 + noteMap[noteName];
        }
        
        /**
         * Get note name in specified notation system
         */
        getNoteInNotation(note, notationSystem) {
            const noteRegex = /([A-G][b#]?)(\d+)/;
            const match = note.match(noteRegex);
            
            if (!match) return note;
            
            const [, noteName, octave] = match;
            const notationSystems = this.config.notationSystems;
            
            if (notationSystems && notationSystems[notationSystem] && notationSystems[notationSystem][noteName]) {
                return notationSystems[notationSystem][noteName] + octave;
            }
            
            return note;
        }
        
        /**
         * Save session data to server
         */
        async saveSession() {
            if (!this.config.user_id || this.config.user_id <= 0) {
                console.log('No user logged in, skipping session save');
                return;
            }
            
            const sessionData = {
                mode: this.gameState.mode,
                difficulty: this.gameState.difficulty,
                duration: Math.floor(this.stats.sessionDuration / 1000), // in seconds
                total_notes: this.stats.totalNotes,
                correct_notes: this.stats.correctNotes,
                incorrect_notes: this.stats.incorrectNotes,
                accuracy: this.stats.accuracy,
                best_streak: this.stats.bestStreak,
                tempo: this.gameState.tempo
            };
            
            try {
                const response = await fetch(this.config.ajax_url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        action: 'srt_save_session',
                        nonce: this.config.nonce,
                        session_data: JSON.stringify(sessionData)
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    console.log('‚úÖ Session saved successfully');
                } else {
                    console.error('‚ùå Failed to save session:', result.data);
                }
            } catch (error) {
                console.error('‚ùå Error saving session:', error);
            }
        }
        
        /**
         * Destroy the engine and cleanup
         */
        destroy() {
            console.log('üóëÔ∏è Destroying Sight Reading Engine...');
            
            // Save session before destroying
            this.saveSession();
            
            // Stop animation
            this.animation.running = false;
            if (this.animation.frame) {
                cancelAnimationFrame(this.animation.frame);
            }
            
            // Release all keys
            this.releaseAllKeys();
            
            // Close MIDI connections
            if (this.midi.access) {
                this.midi.inputs.forEach(input => {
                    input.removeEventListener('midimessage', this.onMIDIMessage);
                });
            }
            
            // Cleanup audio
            if (window.Tone && Tone.Transport) {
                Tone.Transport.stop();
            }
            
            // Remove event listeners
            window.removeEventListener('resize', this.resizeCanvas);
            window.removeEventListener('orientationchange', this.checkOrientation);
            
            console.log('‚úÖ Sight Reading Engine destroyed');
        }
    }
    
    // =================== INITIALIZATION ===================
    
    /**
     * Initialize the sight reading game when DOM is ready
     */
    $(document).ready(function() {
        console.log('üéπ PianoMode Sight Reading - Initializing...');
        
        const gameContainer = document.getElementById('sightReadingGame');
        if (gameContainer) {
            // Create global instance
            window.sightReadingEngine = new SightReadingEngine(gameContainer);
        } else {
            console.error('‚ùå Sight reading game container not found');
        }
    });
    
    // =================== GLOBAL FUNCTIONS ===================
    
    /**
     * Global function to get engine instance
     */
    window.getSightReadingEngine = function() {
        return window.sightReadingEngine;
    };
    
    /**
     * Global cleanup on page unload
     */
    window.addEventListener('beforeunload', function() {
        if (window.sightReadingEngine) {
            window.sightReadingEngine.destroy();
        }
    });
    
})(jQuery);